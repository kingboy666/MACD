!pip install pandas_ta ccxt numpy pandas tenacity -i https://pypi.tuna.tsinghua.edu.cn/simple --quiet

import ccxt
import pandas as pd
import pandas_ta as ta
import traceback
from IPython.display import clear_output, HTML, display, Javascript
import numpy as np
from datetime import datetime, timedelta
import time
import json
import math

# ============================================
# 全局配置常量
# ============================================
MAX_LEVERAGE_BTC_ETH = 50
MAX_LEVERAGE_OTHERS = 30
DEFAULT_LEVERAGE = 20
RISK_PER_TRADE = 0.1
MIN_TRADE_AMOUNT_USD = 1
MAX_OPEN_POSITIONS = 5
COOLDOWN_PERIOD = 5 * 60
ATR_PERIOD = 14
MIN_ATR_PERCENTAGE = 0.005
MAX_ATR_PERCENTAGE = 0.10
MAX_DAILY_TRADES = 20
MAX_DAILY_LOSS = 0.05

# MACD指标配置
MACD_FAST = 6                             # MACD快线周期
MACD_SLOW = 32                            # MACD慢线周期
MACD_SIGNAL = 9                           # MACD信号线周期

# 止损止盈配置
FIXED_SL_PERCENTAGE = 0.02
FIXED_TP_PERCENTAGE = 0.04
MAX_SL_PERCENTAGE = 0.03

# 移动止盈止损配置
TRAILING_STOP_ACTIVATION_PERCENTAGE = 0.01  # 价格移动1%后激活移动止损
TRAILING_STOP_CALLBACK_PERCENTAGE = 0.005   # 回调0.5%触发止损
TRAILING_STOP_CHECK_INTERVAL = 60           # 每60秒检查一次移动止损条件

# 服务器状态检测配置
SERVER_CHECK_INTERVAL = 300                 # 每5分钟检查一次服务器状态
MAX_SERVER_CHECK_FAILURES = 3               # 连续失败3次判定为掉线

# ADX指标配置
ADX_PERIOD = 14                            # ADX计算周期
ADX_THRESHOLD_LOW = 20                     # ADX低于此值视为震荡市场
ADX_THRESHOLD_HIGH = 25                    # ADX高于此值视为趋势市场

# ============================================
# 全局变量
# ============================================
# 交易统计
trade_stats = {
    'initial_balance': 0,
    'current_balance': 0,
    'total_trades': 0,
    'winning_trades': 0,
    'losing_trades': 0,
    'total_profit_loss': 0,
    'daily_trades': 0,
    'daily_pnl': 0,
    'last_reset_date': datetime.now().strftime('%Y-%m-%d'),
    'daily_reset_time': datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
}

# 持仓跟踪器
position_tracker = {
    'positions': {},
    'last_update': datetime.now()
}

# 最新信号
latest_signals = {}

# 冷却期
cooldown_tracker = {}

# 服务器状态跟踪
server_status = {
    'is_online': True,
    'check_failures': 0,
    'last_check_time': time.time()
}

# 移动止损跟踪
trailing_stops = {}

# ============================================# 日常重置函数# ============================================
def check_daily_reset():
    """检查是否需要重置每日统计"""
    now = datetime.now()
    if now.date() > trade_stats['daily_reset_time'].date():
        log_message("INFO", f"每日统计重置 - 昨日交易: {trade_stats['daily_trades']}, 昨日盈亏: {trade_stats['daily_pnl']:.2f} USDT")
        # 重置每日统计
        trade_stats['daily_trades'] = 0
        trade_stats['daily_pnl'] = 0.0
        trade_stats['daily_reset_time'] = now.replace(hour=0, minute=0, second=0, microsecond=0)
        
# ============================================
# 日志功能
# ============================================
def log_message(level, message):
    """增强的日志功能"""
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    color_map = {
        'SUCCESS': '\033[92m',
        'ERROR': '\033[91m',
        'WARNING': '\033[93m',
        'SIGNAL': '\033[96m',
        'TRADE': '\033[95m',
        'INFO': '\033[94m',
        'DEBUG': '\033[90m'
    }
    reset = '\033[0m'
    color = color_map.get(level.upper(), '')
    print(f"{color}[{timestamp}] [{level.upper()}] {message}{reset}")

# ============================================
# 防掉线功能
# ============================================
def prevent_colab_timeout():
    """防止Colab超时断开连接"""
    try:
        display(Javascript('''
            function ClickConnect(){
                console.log("Clicking connect button...");
                document.querySelector("colab-connect-button").click()
            }
            setInterval(ClickConnect, 60000);
        '''))
        log_message("INFO", "已启动防超时功能")
    except Exception as e:
        log_message("WARNING", f"启动防超时功能失败: {str(e)}")

# ============================================
# API连接测试
# ============================================
def test_api_connection():
    """测试交易所API连接"""
    try:
        exchange.fetch_balance()
        log_message("SUCCESS", "API连接测试成功")
        return True
    except Exception as e:
        log_message("ERROR", f"API连接测试失败: {str(e)}")
        return False

# ============================================
# 获取K线数据
# ============================================
def get_klines(symbol, timeframe, limit=100):
    """获取K线数据，带缓存机制"""
    try:
        cache_key = f"{symbol}_{timeframe}"
        if cache_key in klines_cache:
            cached_data, fetch_time = klines_cache[cache_key]
            cache_duration = 60 if timeframe == '1m' else 3600 if timeframe == '1h' else 300
            if (time.time() - fetch_time) < cache_duration:
                return cached_data

        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        klines_cache[cache_key] = (ohlcv, time.time())
        return ohlcv
        
    except Exception as e:
        log_message("ERROR", f"获取 {symbol} {timeframe} K线数据失败: {str(e)}")
        return None

# ============================================
# 获取账户信息
# ============================================
def get_account_info():
    """获取账户信息"""
    try:
        balance = exchange.fetch_balance()
        usdt_balance = balance.get('USDT', {})
        free_balance = usdt_balance.get('free', 0)
        used_balance = usdt_balance.get('used', 0)
        total_balance = usdt_balance.get('total', 0)
        
        unrealized_pnl = 0
        try:
            positions = exchange.fetch_positions()
            for position in positions:
                if position['contracts'] > 0:
                    unrealized_pnl += float(position.get('unrealizedPnl', 0))
        except Exception as e:
            log_message("WARNING", f"获取未实现盈亏失败: {str(e)}")
        
        account_info = {
            'free_balance': free_balance,
            'used_balance': used_balance,
            'total_balance': total_balance,
            'unrealized_pnl': unrealized_pnl,
            'available_balance': free_balance,
            'equity': total_balance + unrealized_pnl
        }
        
        return account_info
        
    except Exception as e:
        log_message("ERROR", f"获取账户信息失败: {str(e)}")
        return None

# ============================================
# 计算仓位大小
# ============================================
def calculate_position_size(account_info, symbol, price, stop_loss, risk_ratio):
    """计算仓位大小，支持同时持仓多单"""
    try:
        # 获取账户余额信息
        available_balance = account_info.get('available_balance', 0)
        total_balance = account_info.get('total_balance', 0)
        
        if available_balance <= 0:
            log_message("ERROR", f"账户可用余额为0，无法计算仓位大小")
            return 0
        
        log_message("INFO", f"账户总额: {total_balance:.4f} USDT, 可用余额: {available_balance:.4f} USDT")
        
        # 为了支持同时持仓多单并确保有足够的保证金空间，使用可用余额的65%作为此次交易的可用资金
        # 对于小额资金账户，需要更加保守以避免保证金不足
        usable_balance = available_balance * 0.65
        log_message("INFO", f"可用于本次交易的资金(可用余额的65%): {usable_balance:.4f} USDT")
        
        # 计算用于此次交易的资金量
        position_value = usable_balance
        log_message("INFO", f"本次交易使用资金: {position_value:.4f} USDT")
        
        if stop_loss <= 0 or price <= 0:
            log_message("ERROR", f"价格或止损价格无效")
            return 0
        
        # 计算仓位大小：资金量除以价格
        position_size = position_value / price
        
        # 应用杠杆 - 确保使用足够的杠杆来放大仓位
        leverage = DEFAULT_LEVERAGE
        position_size = position_size * leverage
        log_message("INFO", f"应用杠杆后的仓位大小: {position_size} (杠杆: {leverage}x)")
        
        # 计算下单金额
        order_amount = position_size * price
        log_message("INFO", f"下单金额: {order_amount:.4f} USDT")
        
        # 检查保证金充足性
        required_margin = order_amount / leverage
        log_message("INFO", f"计算的保证金需求: {required_margin:.4f} USDT")
        
        # 优化保证金检查逻辑，确保保证金充足
        # 考虑平台可能有额外的保证金要求，使用更保守的安全系数
        safety_margin = 0.85  # 进一步降低安全系数，更加保守
        safe_required_margin = required_margin * safety_margin
        
        # 计算可用保证金的最大使用率（70%），留出更多安全空间
        max_allowed_margin = available_balance * 0.70
        
        log_message("INFO", f"安全保证金需求: {safe_required_margin:.4f} USDT, 最大允许使用保证金: {max_allowed_margin:.4f} USDT")
        
        # 取两者中的较小值作为实际限制
        margin_limit = min(safe_required_margin, max_allowed_margin)
        
        if required_margin > margin_limit:
            log_message("WARNING", f"所需保证金 {required_margin:.4f} USDT 超过安全限制 {margin_limit:.4f} USDT，调整仓位大小")
            # 根据安全限制重新计算仓位大小
            position_size = (margin_limit * leverage) / price
            order_amount = position_size * price
            log_message("INFO", f"调整后的仓位大小: {position_size} {symbol.split('/')[0]}")
            log_message("INFO", f"调整后的下单金额: {order_amount:.4f} USDT")
            log_message("INFO", f"调整后的保证金需求: {order_amount/leverage:.4f} USDT")
            
            # 再次检查调整后的保证金是否充足
            adjusted_required_margin = order_amount / leverage
            if adjusted_required_margin > available_balance * 0.85:
                log_message("WARNING", f"即使调整后，保证金需求 {adjusted_required_margin:.4f} USDT 仍接近可用余额的85% {available_balance*0.85:.4f} USDT，再次调整以确保安全")
                # 使用可用余额的85%作为最终保证金限制
                final_margin_limit = available_balance * 0.85
                position_size = (final_margin_limit * leverage) / price
                order_amount = position_size * price
                log_message("INFO", f"最终调整后的仓位大小: {position_size} {symbol.split('/')[0]}")
                log_message("INFO", f"最终调整后的下单金额: {order_amount:.4f} USDT")
                log_message("INFO", f"最终调整后的保证金需求: {order_amount/leverage:.4f} USDT")
        
        # 检查最小交易量要求
        # 获取交易对的最小交易量信息
        try:
            markets = exchange.load_markets()
            market = markets.get(symbol)
            min_amount = market.get('limits', {}).get('amount', {}).get('min', 0.001) if market else 0.001
            log_message("INFO", f"{symbol} 最小交易量要求: {min_amount}")
            
            # 确保仓位不小于最小交易量
            if position_size < min_amount:
                log_message("WARNING", f"计算的仓位 {position_size:.4f} 小于最小交易量 {min_amount}，尝试调整")
                
                # 计算使用最小交易量所需的保证金
                min_order_amount = min_amount * price
                min_required_margin = min_order_amount / leverage
                
                # 检查是否有足够的保证金使用最小交易量
                if min_required_margin <= available_balance * 0.85:  # 使用更保守的保证金检查
                    log_message("INFO", f"使用最小交易量 {min_amount}，所需保证金: {min_required_margin:.4f} USDT")
                    position_size = min_amount
                else:
                    # 如果最小交易量的保证金也不足，使用可用余额的85%作为最大保证金限制
                    log_message("WARNING", f"即使使用最小交易量 {min_amount}，所需保证金 {min_required_margin:.4f} USDT 仍超过可用余额的85% {available_balance*0.85:.4f} USDT")
                    final_margin_limit = available_balance * 0.85
                    position_size = (final_margin_limit * leverage) / price
                    log_message("INFO", f"使用最大可用保证金计算的仓位: {position_size} {symbol.split('/')[0]}")
        except Exception as e:
            log_message("WARNING", f"获取最小交易量信息失败: {str(e)}，使用默认策略")
            # 直接使用可用余额的85%作为最大保证金限制
            final_margin_limit = available_balance * 0.85
            position_size = (final_margin_limit * leverage) / price
            log_message("INFO", f"使用最大可用保证金计算的仓位: {position_size} {symbol.split('/')[0]}")
        
        # 四舍五入到合适的精度
        position_size = round(position_size, 4)
        
        # 最后检查一次仓位是否为0或负数
        if position_size <= 0:
            log_message("ERROR", f"计算的仓位大小为0或负数: {position_size}")
            return 0
        
        log_message("INFO", f"最终计算的仓位大小: {position_size} {symbol.split('/')[0]}")
        return position_size
        
    except Exception as e:
        log_message("ERROR", f"计算仓位大小时出错: {str(e)}")
        traceback.print_exc()
        return 0

# ============================================
# 风险管理检查
# ============================================
def check_and_execute_risk_management(symbol, signal, signal_strength):
    """执行风险管理检查并返回调整后的风险比率"""
    try:
        log_message("TRADE", "开始执行风控检查")
        
        # 检查每日交易次数限制
        if trade_stats['daily_trades'] >= MAX_DAILY_TRADES:
            log_message("WARNING", f"已达到每日最大交易次数 ({MAX_DAILY_TRADES})")
            return None
        
        # 检查每日亏损限制
        account_info = get_account_info()
        if not account_info:
            log_message("ERROR", "获取账户信息失败，无法下单")
            return None
        
        if trade_stats['initial_balance']:
            daily_loss_pct = abs(trade_stats['daily_pnl']) / trade_stats['initial_balance']
            if trade_stats['daily_pnl'] < 0 and daily_loss_pct > MAX_DAILY_LOSS:
                log_message("WARNING", f"已达到每日最大亏损 ({daily_loss_pct*100:.2f}%)")
                return None
        
        # 基础风险比率
        adjusted_risk_ratio = RISK_PER_TRADE
        log_message("INFO", f"最终风险比率: {adjusted_risk_ratio:.4f}")
        
        return adjusted_risk_ratio
        
    except Exception as e:
        log_message("ERROR", f"风控检查失败: {str(e)}")
        return None

# ============================================
# 计算止损止盈价格
# ============================================
def calculate_stop_loss_take_profit(symbol, price, signal, atr_value):
    """计算止损止盈价格"""
    try:
        recent_klines = exchange.fetch_ohlcv(symbol, '1h', limit=10)
        
        if recent_klines and len(recent_klines) >= 5:
            recent_highs = [candle[2] for candle in recent_klines[-10:]]
            recent_lows = [candle[3] for candle in recent_klines[-10:]]
            
            if signal == "做多":
                support_level = min(recent_lows)
                atr_buffer = min(atr_value * 0.5, price * 0.015)
                stop_loss = support_level - atr_buffer
                
                max_sl_distance = price * MAX_SL_PERCENTAGE
                stop_loss = max(stop_loss, price - max_sl_distance)
                
                take_profit = price + (atr_value * 3)
                
            else:
                resistance_level = max(recent_highs)
                atr_buffer = min(atr_value * 0.5, price * 0.015)
                stop_loss = resistance_level + atr_buffer
                
                max_sl_distance = price * MAX_SL_PERCENTAGE
                stop_loss = min(stop_loss, price + max_sl_distance)
                
                take_profit = price - (atr_value * 3)
            
            log_message("INFO", f"计算的止损价格: {stop_loss:.4f}, 止盈价格: {take_profit:.4f}")
            return stop_loss, take_profit
            
    except Exception as e:
        log_message("ERROR", f"获取K线数据失败: {str(e)}")

# ============================================
# 执行交易
# ============================================
def execute_trade(symbol, signal, signal_strength):
    """执行交易"""
    try:
        # 检查冷却期
        if symbol in cooldown_symbols and cooldown_symbols[symbol] > time.time():
            remaining_time = int(cooldown_symbols[symbol] - time.time())
            log_message("DEBUG", f"{symbol} 在冷却期内，还剩 {remaining_time} 秒")
            return False
        
        # 检查是否已有相同方向的持仓
        if symbol in position_tracker['positions']:
            existing_position = position_tracker['positions'][symbol]
            if (existing_position['side'] == 'long' and signal == "做多") or \
               (existing_position['side'] == 'short' and signal == "做空"):
                log_message("DEBUG", f"{symbol} 已有{signal}持仓，不重复开仓")
                return False
        
        # 检查持仓数量限制
        open_positions = len([pos for pos in position_tracker['positions'].values() if pos['size'] > 0])
        if open_positions >= MAX_OPEN_POSITIONS:
            log_message("WARNING", f"已达到最大持仓数量 ({MAX_OPEN_POSITIONS})")
            return False
        
        # 执行风险管理检查
        adjusted_risk = check_and_execute_risk_management(symbol, signal, signal_strength)
        if adjusted_risk is None:
            log_message("WARNING", f"{symbol} 风险管理检查未通过")
            return False
        
        # 获取当前价格
        ticker = exchange.fetch_ticker(symbol)
        price = ticker['last']
        
        # 获取K线数据用于计算止损止盈
        ohlcv = get_klines(symbol, timeframe_1h)
        if ohlcv is None:
            log_message("ERROR", f"{symbol} 获取K线数据失败")
            return False
        
        df = process_klines(ohlcv)
        if df is None or df['ATR_14'].isna().all():
            log_message("ERROR", f"{symbol} ATR指标计算失败")
            return False
        
        atr_value = df['ATR_14'].iloc[-1]
        
        # 计算止损止盈
        sl, tp = calculate_stop_loss_take_profit(symbol, price, signal, atr_value)
        
        # 获取账户信息
        account_info = get_account_info()
        if not account_info:
            log_message("ERROR", f"{symbol} 获取账户信息失败")
            return False
        
        # 计算仓位大小
        position_size = calculate_position_size(account_info, symbol, price, sl, adjusted_risk)
        
        if position_size <= 0:
            log_message("ERROR", f"{symbol} 计算仓位大小失败")
            return False
        
        # 执行下单
        side = 'buy' if signal == "做多" else 'sell'
        pos_side = 'long' if signal == "做多" else 'short'
        
        try:
            log_message("TRADE", f"{symbol} 准备下单: {side} {position_size} @ {price}")
            
            # 下单前的最终保证金检查
            # 重新获取最新的账户信息
            latest_account_info = get_account_info()
            if latest_account_info:
                latest_available_balance = latest_account_info.get('available_balance', 0)
                
                # 重新计算实际需要的保证金
                order_amount = position_size * price
                required_margin = order_amount / DEFAULT_LEVERAGE
                
                # 使用与calculate_position_size函数相同的保守计算方法
                safety_margin = 0.85  # 保守的安全系数
                safe_required_margin = required_margin * safety_margin
                
                # 计算可用保证金的最大使用率（70%）
                max_allowed_margin = latest_available_balance * 0.70
                
                # 取两者中的较小值作为实际限制
                margin_limit = min(safe_required_margin, max_allowed_margin)
                
                log_message("INFO", f"下单前最终保证金检查: 可用余额={latest_available_balance:.4f} USDT, 所需保证金={required_margin:.4f} USDT, 安全限制={margin_limit:.4f} USDT")
                
                if required_margin > margin_limit:
                    log_message("ERROR", f"{symbol} 保证金不足: 所需 {required_margin:.4f} USDT 超过安全限制 {margin_limit:.4f} USDT")
                    # 尝试使用更保守的方法调整仓位
                    # 1. 首先使用margin_limit作为最大可用保证金来调整仓位
                    new_position_size = (margin_limit * DEFAULT_LEVERAGE) / price
                    
                    # 确保调整后的仓位大于最小交易量
                    try:
                        markets = exchange.load_markets()
                        market = markets.get(symbol)
                        min_amount = market.get('limits', {}).get('amount', {}).get('min', 0.001) if market else 0.001
                        new_position_size = max(new_position_size, min_amount)
                    except:
                        pass
                    
                    # 计算调整后的仓位实际需要的保证金
                    new_order_amount = new_position_size * price
                    new_required_margin = new_order_amount / DEFAULT_LEVERAGE
                    
                    # 如果调整后仍不足，使用可用余额的35%作为最终保证金限制（更保守）
                        if new_required_margin > latest_available_balance * 0.35:
                            log_message("WARNING", f"即使使用安全限制，保证金需求 {new_required_margin:.4f} USDT 仍过高，使用更保守的35%可用余额")
                            final_margin_limit = latest_available_balance * 0.35
                            new_position_size = (final_margin_limit * DEFAULT_LEVERAGE) / price
                            new_position_size = round(new_position_size, 4)
                            
                            # 重新计算保证金
                            new_order_amount = new_position_size * price
                            new_required_margin = new_order_amount / DEFAULT_LEVERAGE
                            log_message("INFO", f"使用可用余额的35%作为保证金限制: {final_margin_limit:.4f} USDT")
                    
                    # 四舍五入到合适精度
                    new_position_size = round(new_position_size, 4)
                    log_message("INFO", f"使用调整后的仓位大小: {new_position_size} {symbol.split('/')[0]}")
                    
                    # 使用调整后的仓位大小
                    position_size = new_position_size
                    order_amount = position_size * price
                    required_margin = order_amount / DEFAULT_LEVERAGE
                    log_message("INFO", f"调整后所需保证金: {required_margin:.4f} USDT")
            else:
                log_message("WARNING", f"{symbol} 获取最新账户信息失败，继续下单")
            
            # 下单前最后一次保证金检查 - 使用极低的保证金比例确保成功
            final_account_info = get_account_info()
            if final_account_info:
                final_available_balance = final_account_info.get('available_balance', 0)
                # 使用极低的保证金比例：确保保证金需求不超过可用余额的30%
                if required_margin > final_available_balance * 0.30:
                    log_message("ERROR", f"{symbol} 最终保证金检查失败: 所需 {required_margin:.4f} USDT 超过可用余额的30% {final_available_balance*0.30:.4f} USDT")
                    # 再次调整到可用余额的30%
                    final_safe_margin_limit = final_available_balance * 0.30
                    position_size = (final_safe_margin_limit * DEFAULT_LEVERAGE) / price
                    position_size = round(position_size, 4)
                    log_message("INFO", f"最终安全调整后的仓位大小: {position_size} {symbol.split('/')[0]}")
                    order_amount = position_size * price
                    required_margin = order_amount / DEFAULT_LEVERAGE
                    log_message("INFO", f"最终安全调整后所需保证金: {required_margin:.4f} USDT")
                    
                    # 确保仓位大于最小交易量
                    try:
                        markets = exchange.load_markets()
                        market = markets.get(symbol)
                        min_amount = market.get('limits', {}).get('amount', {}).get('min', 0.001) if market else 0.001
                        if position_size < min_amount:
                            log_message("ERROR", f"{symbol} 调整后的仓位 {position_size} 小于最小交易量 {min_amount}，无法下单")
                            return False
                    except:
                        pass
            
            # 市价下单前的终极安全检查
            if required_margin > final_available_balance * 0.25:
                log_message("ERROR", f"{symbol} 终极保证金检查失败: 所需 {required_margin:.4f} USDT 仍超过可用余额的25% {final_available_balance*0.25:.4f} USDT")
                # 使用可用余额的25%作为绝对上限
                ultra_safe_margin_limit = final_available_balance * 0.25
                position_size = (ultra_safe_margin_limit * DEFAULT_LEVERAGE) / price
                position_size = round(position_size, 4)
                log_message("INFO", f"终极安全调整后的仓位大小: {position_size} {symbol.split('/')[0]}")
                order_amount = position_size * price
                required_margin = order_amount / DEFAULT_LEVERAGE
                log_message("INFO", f"终极安全调整后所需保证金: {required_margin:.4f} USDT")
            
            log_message("TRADE", f"{symbol} 最终确认下单: {side} {position_size} @ {price}, 保证金需求: {required_margin:.4f} USDT")
            
            # 市价下单
            order = exchange.create_order(
                symbol=symbol,
                type='market',
                side=side,
                amount=position_size,
                params={'posSide': pos_side}
            )
            
            log_message("SUCCESS", f"{symbol} 下单成功，订单ID: {order['id']}")
            
            # 等待订单执行
            time.sleep(2)
            
            # 验证订单状态
            try:
                order_status = exchange.fetch_order(order['id'], symbol)
                if order_status['status'] != 'closed':
                    log_message("WARNING", f"{symbol} 订单未完全成交: {order_status['status']}")
                
                actual_price = float(order_status.get('average', price))
                actual_size = float(order_status.get('filled', position_size))
                
            except Exception as e:
                log_message("WARNING", f"{symbol} 获取订单状态失败: {str(e)}")
                actual_price = price
                actual_size = position_size
            
            log_message("SUCCESS", f"{symbol} 成交确认: {side} {actual_size} @ {actual_price}")
            
            # 设置止损止盈
            sl_side = 'sell' if signal == "做多" else 'buy'
            tp_side = 'sell' if signal == "做多" else 'buy'
            
            sl_order_id = None
            tp_order_id = None
            
            try:
                # 设置止损
                sl_order = exchange.create_order(
                    symbol=symbol,
                    type='stop',
                    side=sl_side,
                    amount=actual_size,
                    price=sl,
                    params={'stopLossPrice': sl, 'posSide': pos_side}
                )
                sl_order_id = sl_order['id']
                log_message("SUCCESS", f"{symbol} 设置止损成功: {sl}")
                
                # 设置止盈
                tp_order = exchange.create_order(
                    symbol=symbol,
                    type='take_profit',
                    side=tp_side,
                    amount=actual_size,
                    price=tp,
                    params={'takeProfitPrice': tp, 'posSide': pos_side}
                )
                tp_order_id = tp_order['id']
                log_message("SUCCESS", f"{symbol} 设置止盈成功: {tp}")
                
            except Exception as e:
                log_message("ERROR", f"{symbol} 设置止损止盈失败: {str(e)}")
            
            # 更新持仓跟踪器
            position_tracker['positions'][symbol] = {
                'entry_price': actual_price,
                'size': actual_size,
                'side': 'long' if signal == "做多" else 'short',
                'pnl': 0.0,
                'sl': sl,
                'tp': tp,
                'entry_time': datetime.now(),
                'leverage': DEFAULT_LEVERAGE,
                'order_id': order['id'],
                'sl_order_id': sl_order_id,
                'tp_order_id': tp_order_id
            }
            
            # 设置移动止盈跟踪
            trailing_stops[symbol] = {
                'active': False,
                'activation_price': tp if signal == "做多" else sl,
                'current_trigger': None,
                'side': 'long' if signal == "做多" else 'short',
                'size': actual_size,
                'last_check': time.time()
            }
            
            # 更新交易统计
            trade_stats['total_trades'] += 1
            trade_stats['daily_trades'] += 1
            
            # 设置冷却期
            cooldown_symbols[symbol] = time.time() + COOLDOWN_PERIOD
            
            return True
            
        except Exception as e:
            log_message("ERROR", f"{symbol} 下单失败: {str(e)}")
            return False
            
    except Exception as e:
        log_message("ERROR", f"{symbol} 执行交易失败: {str(e)}")
        return False

# ============================================
# 更新持仓状态
# ============================================
def update_positions():
    """更新所有持仓的状态"""
    try:
        from datetime import datetime
        now = datetime.now()
        positions = position_tracker['positions'].copy()
        
        for symbol, position in positions.items():
            try:
                # 获取当前价格
                ticker = exchange.fetch_ticker(symbol)
                current_price = ticker['last']
                
                # 计算未实现盈亏
                if position['side'] == 'long':
                    pnl_percentage = (current_price - position['entry_price']) / position['entry_price']
                else:
                    pnl_percentage = (position['entry_price'] - current_price) / position['entry_price']
                
                pnl = position['size'] * position['entry_price'] * pnl_percentage * position['leverage']
                position_tracker['positions'][symbol]['pnl'] = pnl
                
                # 检查移动止盈条件
                check_trailing_stop(symbol, current_price)
                
            except Exception as e:
                log_message("ERROR", f"{symbol} 更新持仓状态失败: {str(e)}")
        
        # 检查已平仓的持仓
        check_closed_positions()
                
    except Exception as e:
        log_message("ERROR", f"更新持仓状态时出错: {str(e)}")

# ============================================
# 平仓函数
# ============================================
def close_position(symbol, reason="手动平仓"):
    """平仓指定持仓"""
    try:
        if symbol not in position_tracker['positions']:
            log_message("WARNING", f"{symbol} 没有持仓")
            return False
        
        position = position_tracker['positions'][symbol]
        
        # 准备平仓订单
        side = 'sell' if position['side'] == 'long' else 'buy'
        pos_side = position['side']
        
        log_message("TRADE", f"{symbol} 准备平仓: {reason}")
        
        # 市价平仓
        order = exchange.create_order(
            symbol=symbol,
            type='market',
            side=side,
            amount=position['size'],
            params={'posSide': pos_side, 'reduceOnly': True}
        )
        
        log_message("SUCCESS", f"{symbol} 平仓订单提交成功，订单ID: {order['id']}")
        
        # 取消止损止盈订单
        try:
            if position.get('sl_order_id'):
                exchange.cancel_order(position['sl_order_id'], symbol)
                log_message("INFO", f"{symbol} 止损订单已取消")
        except:
            pass
        
        try:
            if position.get('tp_order_id'):
                exchange.cancel_order(position['tp_order_id'], symbol)
                log_message("INFO", f"{symbol} 止盈订单已取消")
        except:
            pass
        
        # 记录盈亏
        final_pnl = position.get('pnl', 0)
        trade_stats['total_profit_loss'] += final_pnl
        trade_stats['daily_pnl'] += final_pnl
        
        if final_pnl > 0:
            trade_stats['wins'] += 1
            trade_stats['total_profit'] += final_pnl
            log_message("SUCCESS", f"{symbol} 盈利平仓: +{final_pnl:.2f} USDT ({reason})")
        else:
            trade_stats['losses'] += 1
            trade_stats['total_loss'] += abs(final_pnl)
            log_message("WARNING", f"{symbol} 亏损平仓: {final_pnl:.2f} USDT ({reason})")
        
        # 从跟踪器移除
        del position_tracker['positions'][symbol]
        if symbol in trailing_stops:
            del trailing_stops[symbol]
        
        return True
        
    except Exception as e:
        log_message("ERROR", f"{symbol} 平仓失败: {str(e)}")
        return False

# ============================================
# 移动止盈功能
# ============================================
def check_trailing_stop(symbol, current_price):
    """检查并更新移动止盈"""
    if symbol not in trailing_stops or symbol not in position_tracker['positions']:
        return
    
    ts = trailing_stops[symbol]
    position = position_tracker['positions'][symbol]
    
    # 检查是否需要更新
    if time.time() - ts['last_check'] < TRAILING_STOP_CHECK_INTERVAL:
        return
    
    ts['last_check'] = time.time()
    
    try:
        # 确保键名一致性
        if 'activated' in ts and 'active' not in ts:
            ts['active'] = ts['activated']
        elif 'active' not in ts:
            ts['active'] = False
            
        # 多头持仓
        if ts['side'] == 'long':
            # 检查是否达到激活条件
            if not ts['active'] and current_price >= position['entry_price'] * (1 + TRAILING_STOP_ACTIVATION_PERCENTAGE):
                ts['active'] = True
                ts['current_trigger'] = current_price * (1 - TRAILING_STOP_CALLBACK_PERCENTAGE)
                log_message("INFO", f"{symbol} 多头移动止盈已激活，触发价: {ts['current_trigger']:.4f}")
            
            # 如果已激活，检查是否需要更新触发价
            elif ts['active']:
                # 如果价格创新高，更新触发价
                if current_price > (ts['current_trigger'] / (1 - TRAILING_STOP_CALLBACK_PERCENTAGE)):
                    new_trigger = current_price * (1 - TRAILING_STOP_CALLBACK_PERCENTAGE)
                    if new_trigger > ts['current_trigger']:
                        ts['current_trigger'] = new_trigger
                        log_message("INFO", f"{symbol} 多头移动止盈更新，新触发价: {ts['current_trigger']:.4f}")
                
                # 检查是否触发平仓
                if ts['active'] and current_price <= ts['current_trigger']:
                    log_message("TRADE", f"{symbol} 触发多头移动止盈，当前价: {current_price:.4f}, 触发价: {ts['current_trigger']:.4f}")
                    close_position(symbol, "移动止盈触发")
        
        # 空头持仓
        else:
            # 检查是否达到激活条件
            if not ts['active'] and current_price <= position['entry_price'] * (1 - TRAILING_STOP_ACTIVATION_PERCENTAGE):
                ts['active'] = True
                ts['current_trigger'] = current_price * (1 + TRAILING_STOP_CALLBACK_PERCENTAGE)
                log_message("INFO", f"{symbol} 空头移动止盈已激活，触发价: {ts['current_trigger']:.4f}")
            
            # 如果已激活，检查是否需要更新触发价
            elif ts['active']:
                # 如果价格创新低，更新触发价
                if current_price < (ts['current_trigger'] / (1 + TRAILING_STOP_CALLBACK_PERCENTAGE)):
                    new_trigger = current_price * (1 + TRAILING_STOP_CALLBACK_PERCENTAGE)
                    if new_trigger < ts['current_trigger']:
                        ts['current_trigger'] = new_trigger
                        log_message("INFO", f"{symbol} 空头移动止盈更新，新触发价: {ts['current_trigger']:.4f}")
                
                # 检查是否触发平仓
                if ts['active'] and current_price >= ts['current_trigger']:
                    log_message("TRADE", f"{symbol} 触发空头移动止盈，当前价: {current_price:.4f}, 触发价: {ts['current_trigger']:.4f}")
                    close_position(symbol, "移动止盈触发")
    
    except Exception as e:
        log_message("ERROR", f"{symbol} 检查移动止盈失败: {str(e)}")

# ============================================
# 检查已平仓的持仓
# ============================================
def check_closed_positions():
    """检查是否有已经被交易所平仓的持仓"""
    try:
        # 获取当前持仓
        exchange_positions = {}
        try:
            positions = exchange.fetch_positions()
            for position in positions:
                if float(position['contracts']) > 0:
                    symbol = position['symbol']
                    exchange_positions[symbol] = position
        except Exception as e:
            log_message("ERROR", f"获取交易所持仓失败: {str(e)}")
            return
        
        # 检查本地跟踪的持仓是否在交易所中已经平仓
        for symbol in list(position_tracker['positions'].keys()):
            if symbol not in exchange_positions:
                log_message("INFO", f"{symbol} 在交易所已平仓，同步本地状态")
                position = position_tracker['positions'][symbol]
                
                # 记录盈亏
                final_pnl = position.get('pnl', 0)
                trade_stats['total_profit_loss'] += final_pnl
                trade_stats['daily_pnl'] += final_pnl
                
                if final_pnl > 0:
                    trade_stats['winning_trades'] += 1
                    log_message("SUCCESS", f"{symbol} 盈利平仓: +{final_pnl:.2f} USDT (交易所平仓)")
                else:
                    trade_stats['losing_trades'] += 1
                    log_message("WARNING", f"{symbol} 亏损平仓: {final_pnl:.2f} USDT (交易所平仓)")
                
                # 从跟踪器移除
                del position_tracker['positions'][symbol]
                if symbol in trailing_stops:
                    del trailing_stops[symbol]
    
    except Exception as e:
        log_message("ERROR", f"检查已平仓持仓失败: {str(e)}")
        trade_stats['daily_trades'] = 0
        trade_stats['daily_pnl'] = 0.0
        trade_stats['daily_reset_time'] = now.replace(hour=0, minute=0, second=0, microsecond=0)

# ============================================
# 服务器状态检测函数
# ============================================
def check_server_status():
    """检查服务器连接状态"""
    try:
        # 尝试获取服务器时间，这是一个轻量级API调用
        exchange.fetch_time()
        
        # 如果成功，重置失败计数
        server_status['check_failures'] = 0
        server_status['is_online'] = True
        return True
    except Exception as e:
        # 增加失败计数
        server_status['check_failures'] += 1
        
        # 如果连续失败次数超过阈值，标记为离线
        if server_status['check_failures'] >= MAX_SERVER_CHECK_FAILURES:
            server_status['is_online'] = False
            log_message("WARNING", f"服务器连接异常 ({server_status['check_failures']}次失败): {str(e)}")
        
        return False

# ============================================
# 移动止损更新函数
# ============================================
def update_trailing_stops():
    """更新所有持仓的移动止损"""
    if not server_status['is_online']:
        log_message("WARNING", "服务器离线，跳过移动止损更新")
        return
    
    for symbol, position in list(position_tracker['positions'].items()):
        try:
            # 初始化移动止损跟踪（如果不存在）
            if symbol not in trailing_stops:
                trailing_stops[symbol] = {
                    'active': False,
                    'activation_price': 0,
                    'current_stop': 0
                }
            # 确保键名一致性（处理旧版本数据）
            elif 'activated' in trailing_stops[symbol] and 'active' not in trailing_stops[symbol]:
                trailing_stops[symbol]['active'] = trailing_stops[symbol]['activated']
            
            # 获取当前市场价格
            ticker = exchange.fetch_ticker(symbol)
            current_price = ticker['last']
            
            # 多头持仓
            if position['side'] == 'long':
                # 检查是否已激活移动止损
                if not trailing_stops[symbol]['active']:
                    # 计算激活价格（入场价格 + 激活百分比）
                    activation_price = position['entry_price'] * (1 + TRAILING_STOP_ACTIVATION_PERCENTAGE)
                    trailing_stops[symbol]['activation_price'] = activation_price
                     
                    # 如果价格达到激活水平，激活移动止损
                    if current_price >= activation_price:
                        trailing_stops[symbol]['active'] = True
                        trailing_stops[symbol]['current_stop'] = current_price * (1 - TRAILING_STOP_CALLBACK_PERCENTAGE)
                        log_message("INFO", f"{symbol} 多头移动止损已激活，当前价格: {current_price:.4f}，止损价格: {trailing_stops[symbol]['current_stop']:.4f}")
                
                # 如果已激活，更新止损价格
                elif current_price > position['entry_price']:
                    new_stop = current_price * (1 - TRAILING_STOP_CALLBACK_PERCENTAGE)
                    
                    # 只有当新止损价格高于当前止损价格时才更新
                    if new_stop > trailing_stops[symbol]['current_stop']:
                        old_stop = trailing_stops[symbol]['current_stop']
                        trailing_stops[symbol]['current_stop'] = new_stop
                        
                        log_message("INFO", f"{symbol} 多头移动止损更新: {old_stop:.4f} -> {new_stop:.4f}")
                        
                        # 更新交易所订单
                        if position.get('sl_order_id'):
                            try:
                                # 取消旧的止损订单
                                exchange.cancel_order(position['sl_order_id'], symbol)
                                
                                # 创建新的止损订单
                                sl_order = exchange.create_order(
                                    symbol=symbol,
                                    type='stop_market',
                                    side='sell',
                                    amount=position['size'],
                                    price=new_stop,
                                    params={
                                        'stopPrice': new_stop,
                                        'posSide': 'long',
                                        'reduceOnly': True
                                    }
                                )
                                
                                # 更新止损订单ID
                                position_tracker['positions'][symbol]['sl_order_id'] = sl_order['id']
                                log_message("INFO", f"{symbol} 多头移动止损订单已更新，新订单ID: {sl_order['id']}")
                                
                            except Exception as e:
                                log_message("ERROR", f"{symbol} 更新多头移动止损订单失败: {str(e)}")
            
            # 空头持仓
            elif position['side'] == 'short':
                # 检查是否已激活移动止损
                if not trailing_stops[symbol]['active']:
                    # 计算激活价格（入场价格 - 激活百分比）
                    activation_price = position['entry_price'] * (1 - TRAILING_STOP_ACTIVATION_PERCENTAGE)
                    trailing_stops[symbol]['activation_price'] = activation_price
                    
                    # 如果价格达到激活水平，激活移动止损
                    if current_price <= activation_price:
                        trailing_stops[symbol]['active'] = True
                        trailing_stops[symbol]['current_stop'] = current_price * (1 + TRAILING_STOP_CALLBACK_PERCENTAGE)
                        log_message("INFO", f"{symbol} 空头移动止损已激活，当前价格: {current_price:.4f}，止损价格: {trailing_stops[symbol]['current_stop']:.4f}")
                
                # 如果已激活，更新止损价格
                elif current_price < position['entry_price']:
                    new_stop = current_price * (1 + TRAILING_STOP_CALLBACK_PERCENTAGE)
                    
                    # 只有当新止损价格低于当前止损价格时才更新
                    if new_stop < trailing_stops[symbol]['current_stop'] or trailing_stops[symbol]['current_stop'] == 0:
                        old_stop = trailing_stops[symbol]['current_stop']
                        trailing_stops[symbol]['current_stop'] = new_stop
                        
                        log_message("INFO", f"{symbol} 空头移动止损更新: {old_stop:.4f} -> {new_stop:.4f}")
                        
                        # 更新交易所订单
                        if position.get('sl_order_id'):
                            try:
                                # 取消旧的止损订单
                                exchange.cancel_order(position['sl_order_id'], symbol)
                                
                                # 创建新的止损订单
                                sl_order = exchange.create_order(
                                    symbol=symbol,
                                    type='stop_market',
                                    side='buy',
                                    amount=position['size'],
                                    price=new_stop,
                                    params={
                                        'stopPrice': new_stop,
                                        'posSide': 'short',
                                        'reduceOnly': True
                                    }
                                )
                                
                                # 更新止损订单ID
                                position_tracker['positions'][symbol]['sl_order_id'] = sl_order['id']
                                log_message("INFO", f"{symbol} 空头移动止损订单已更新，新订单ID: {sl_order['id']}")
                                
                            except Exception as e:
                                log_message("ERROR", f"{symbol} 更新空头移动止损订单失败: {str(e)}")
        
        except Exception as e:
            log_message("ERROR", f"{symbol} 更新移动止损时出错: {str(e)}")

# ============================================
# 处理K线数据并计算指标
# ============================================
def process_klines(ohlcv):
    """处理K线数据并计算技术指标"""
    try:
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df.set_index('timestamp', inplace=True)

        # 计算MACD指标
        macd = ta.macd(df['close'], fast=MACD_FAST, slow=MACD_SLOW, signal=MACD_SIGNAL)
        df['MACD'] = macd['MACD_' + str(MACD_FAST) + '_' + str(MACD_SLOW) + '_' + str(MACD_SIGNAL)]
        df['MACD_SIGNAL'] = macd['MACDs_' + str(MACD_FAST) + '_' + str(MACD_SLOW) + '_' + str(MACD_SIGNAL)]
        df['MACD_HIST'] = macd['MACDh_' + str(MACD_FAST) + '_' + str(MACD_SLOW) + '_' + str(MACD_SIGNAL)]
        
        # 计算ATR（仅用于止盈止损）
        df['ATR_14'] = ta.atr(high=df['high'], low=df['low'], close=df['close'], length=ATR_PERIOD)
        
        # 计算ADX（用于趋势/震荡判断）
        adx = ta.adx(high=df['high'], low=df['low'], close=df['close'], length=ADX_PERIOD)
        df['ADX'] = adx[f'ADX_{ADX_PERIOD}']
        
        return df
        
    except Exception as e:
        log_message("ERROR", f"处理K线数据失败: {str(e)}")
        return None

# ============================================
# 生成交易信号 - MACD金叉/死叉 + ADX过滤
# ============================================
def generate_signal(symbol):
    """基于MACD金叉/死叉生成交易信号，使用ADX过滤震荡市场"""
    try:
        # 使用30分钟时间周期
        ohlcv = get_klines(symbol, '30m', limit=100)
        if ohlcv is None or len(ohlcv) < 50:
            log_message("WARNING", f"{symbol} 获取K线数据失败或数据不足")
            return None, 0
        
        df = process_klines(ohlcv)
        if df is None:
            return None, 0
        
        # 检查是否成功计算了指标
        if df['MACD'].isna().all() or df['MACD_SIGNAL'].isna().all():
            log_message("WARNING", f"{symbol} MACD指标计算失败")
            return None, 0
        
        current_macd = df['MACD'].iloc[-1]
        current_signal = df['MACD_SIGNAL'].iloc[-1]
        prev_macd = df['MACD'].iloc[-2]
        prev_signal = df['MACD_SIGNAL'].iloc[-2]
        
        # === ADX趋势/震荡判断 ===
        adx_value = df['ADX'].iloc[-1] if 'ADX' in df.columns and not df['ADX'].isna().all() else 0
        is_trending = adx_value > ADX_THRESHOLD_HIGH
        is_ranging = adx_value < ADX_THRESHOLD_LOW
        
        # 如果ADX低于阈值，市场处于震荡状态，不产生信号
        if is_ranging:
            log_message("DEBUG", f"{symbol} ADX值为 {adx_value:.2f}，低于{ADX_THRESHOLD_LOW}，震荡市场，不产生信号")
            return None, 0
        
        # ATR波动率过滤（仅用于避免过度波动的市场）
        if not df['ATR_14'].isna().all():
            current_close = df['close'].iloc[-1]
            atr_value = df['ATR_14'].iloc[-1]
            atr_percentage = atr_value / current_close
            
            if atr_percentage > MAX_ATR_PERCENTAGE:
                log_message("DEBUG", f"{symbol} ATR波动率过高 ({atr_percentage:.4f})，市场过于激烈")
                return None, 0
        
        # === 核心信号：MACD金叉/死叉 ===
        signal = None
        strength = 0
        
        # MACD金叉 - 做多信号
        if prev_macd <= prev_signal and current_macd > current_signal:
            signal = "做多"
            # 计算信号强度：基于MACD差距和ADX值
            macd_diff = current_macd - current_signal
            # 如果是趋势市场，增加信号强度
            adx_bonus = 10 if is_trending else 0
            strength = min(100, int(50 + abs(macd_diff) * 1000 + adx_bonus))
            log_message("SIGNAL", f"{symbol} MACD金叉，ADX={adx_value:.2f}，生成做多信号，强度: {strength}")
        
        # MACD死叉 - 做空信号
        elif prev_macd >= prev_signal and current_macd < current_signal:
            signal = "做空"
            # 计算信号强度：基于MACD差距和ADX值
            macd_diff = current_signal - current_macd
            # 如果是趋势市场，增加信号强度
            adx_bonus = 10 if is_trending else 0
            strength = min(100, int(50 + abs(macd_diff) * 1000 + adx_bonus))
            log_message("SIGNAL", f"{symbol} MACD死叉，ADX={adx_value:.2f}，生成做空信号，强度: {strength}")
        
        return signal, strength
        
    except Exception as e:
        log_message("ERROR", f"{symbol} 生成信号失败: {str(e)}")
        return None, 0

# ============================================# 检查MACD交叉平仓条件# ============================================def check_macd_close_conditions():
    """检查现有持仓是否满足MACD交叉平仓条件"""
    try:
        # 遍历所有持仓
        for symbol, position in list(position_tracker['positions'].items()):
            if position['size'] <= 0:
                continue
                
            try:
                # 获取最新的K线数据和MACD指标
                ohlcv = get_klines(symbol, '30m', limit=100)
                if ohlcv is None or len(ohlcv) < 50:
                    continue
                
                df = process_klines(ohlcv)
                if df is None:
                    continue
                
                # 检查是否成功计算了MACD指标
                if df['MACD'].isna().all() or df['MACD_SIGNAL'].isna().all():
                    continue
                
                current_macd = df['MACD'].iloc[-1]
                current_signal = df['MACD_SIGNAL'].iloc[-1]
                prev_macd = df['MACD'].iloc[-2]
                prev_signal = df['MACD_SIGNAL'].iloc[-2]
                
                # 检查平仓条件
                # 多头持仓：当快线下穿突破慢线时（死叉时）平仓
                if position['side'] == 'long':
                    if prev_macd >= prev_signal and current_macd < current_signal:
                        log_message("SIGNAL", f"{symbol} 多头持仓触发MACD死叉平仓条件")
                        close_position(symbol, "MACD死叉触发平仓")
                
                # 空头持仓：当快线上穿突破慢线时（金叉时）平仓
                elif position['side'] == 'short':
                    if prev_macd <= prev_signal and current_macd > current_signal:
                        log_message("SIGNAL", f"{symbol} 空头持仓触发MACD金叉平仓条件")
                        close_position(symbol, "MACD金叉触发平仓")
                
            except Exception as e:
                log_message("ERROR", f"{symbol} 检查MACD平仓条件时出错: {str(e)}")
                
    except Exception as e:
        log_message("ERROR", f"检查MACD平仓条件时出错: {str(e)}")

# ============================================# 可视化界面功能# ============================================def display_trading_stats():
    """显示交易统计信息"""
    try:
        log_message("INFO", "=" * 60)
        log_message("INFO", "交易统计")
        log_message("INFO", "=" * 60)
        
        account_info = get_account_info()
        if account_info:
            log_message("INFO", f"账户余额: {account_info['total_balance']:.2f} USDT")
            log_message("INFO", f"可用余额: {account_info['free_balance']:.2f} USDT")
            log_message("INFO", f"未实现盈亏: {account_info['unrealized_pnl']:.2f} USDT")
        
        if trade_stats['initial_balance']:
            total_return = (account_info['total_balance'] - trade_stats['initial_balance']) / trade_stats['initial_balance'] * 100 if account_info else 0
            log_message("INFO", f"总收益率: {total_return:.2f}%")
        
        log_message("INFO", f"总交易次数: {trade_stats.get('total_trades', 0)}")
        log_message("INFO", f"今日交易次数: {trade_stats.get('daily_trades', 0)}")
        log_message("INFO", f"今日盈亏: {trade_stats.get('daily_pnl', 0):.2f} USDT")
        
        if trade_stats.get('total_trades', 0) > 0:
            wins = trade_stats.get('winning_trades', trade_stats.get('wins', 0))
            losses = trade_stats.get('losing_trades', trade_stats.get('losses', 0))
            win_rate = wins / trade_stats.get('total_trades', 1) * 100
            log_message("INFO", f"胜率: {win_rate:.2f}%")
            log_message("INFO", f"盈利次数: {wins}")
            log_message("INFO", f"亏损次数: {losses}")
            log_message("INFO", f"平均盈利: {trade_stats.get('avg_profit', 0):.2f} USDT")
            log_message("INFO", f"平均亏损: {trade_stats.get('avg_loss', 0):.2f} USDT")
            log_message("INFO", f"盈亏比: {trade_stats.get('profit_factor', 0):.2f}")
            log_message("INFO", f"最大盈利: {trade_stats.get('largest_profit', 0):.2f} USDT")
            log_message("INFO", f"最大亏损: {trade_stats.get('largest_loss', 0):.2f} USDT")
            log_message("INFO", f"最大连胜: {trade_stats.get('max_consecutive_wins', 0)}")
            log_message("INFO", f"最大连亏: {trade_stats.get('max_consecutive_losses', 0)}")
        
        log_message("INFO", f"当前持仓数量: {len(position_tracker['positions'])}")
        
        if position_tracker['positions']:
            log_message("INFO", "\n当前持仓:")
            for symbol, pos in position_tracker['positions'].items():
                pnl_pct = (pos['pnl'] / (pos['entry_price'] * pos['size'])) * 100 if pos['size'] > 0 else 0
                log_message("INFO", f"  {symbol}: {pos['side']} {pos['size']} @ {pos['entry_price']:.4f}, 盈亏: {pos['pnl']:.2f} USDT ({pnl_pct:.2f}%)")
        
        log_message("INFO", "=" * 60)
        
    except Exception as e:
        log_message("ERROR", f"显示交易统计时出错: {str(e)}")

# ============================================# 可视化界面功能# ============================================def display_dashboard():
    """显示交易系统的可视化仪表板"""
    try:
        clear_output(wait=True)
        
        # 获取最新的账户信息
        account_info = get_account_info()
        if account_info:
            trade_stats['current_balance'] = account_info.get('total_balance', 0)
        
        # 计算总盈亏百分比
        if trade_stats['initial_balance'] > 0:
            total_pnl_percentage = (trade_stats['current_balance'] - trade_stats['initial_balance']) / trade_stats['initial_balance'] * 100
        else:
            total_pnl_percentage = 0
        
        # 创建仪表板HTML
        dashboard_html = """
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                background-color: #1a1a2e;
                color: #ffffff;
                margin: 0;
                padding: 20px;
            }
            .dashboard {
                max-width: 1400px;
                margin: 0 auto;
            }
            .header {
                background: linear-gradient(135deg, #16213e, #0f3460);
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 20px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            .header h1 {
                margin: 0;
                font-size: 28px;
                text-align: center;
                color: #e94560;
            }
            .stats-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin-bottom: 20px;
            }
            .stat-card {
                background: linear-gradient(135deg, #16213e, #1a1a2e);
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                transition: transform 0.3s, box-shadow 0.3s;
            }
            .stat-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            }
            .stat-card h3 {
                margin: 0 0 10px 0;
                font-size: 16px;
                color: #86c232;
                text-transform: uppercase;
                letter-spacing: 1px;
            }
            .stat-card .value {
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 5px;
            }
            .stat-card .change {
                font-size: 14px;
            }
            .positive {
                color: #4CAF50;
            }
            .negative {
                color: #f44336;
            }
            .neutral {
                color: #ff9800;
            }
            .section {
                background: linear-gradient(135deg, #16213e, #1a1a2e);
                padding: 20px;
                border-radius: 10px;
                margin-bottom: 20px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            .section h2 {
                margin: 0 0 15px 0;
                font-size: 22px;
                color: #e94560;
                border-bottom: 2px solid #e94560;
                padding-bottom: 10px;
            }
            .positions-table, .signals-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
            }
            .positions-table th, .signals-table th {
                background-color: #0f3460;
                color: white;
                padding: 12px;
                text-align: left;
                font-weight: bold;
            }
            .positions-table td, .signals-table td {
                padding: 10px;
                border-bottom: 1px solid #2a2a4e;
            }
            .positions-table tr:nth-child(even), .signals-table tr:nth-child(even) {
                background-color: rgba(255, 255, 255, 0.03);
            }
            .positions-table tr:hover, .signals-table tr:hover {
                background-color: rgba(255, 255, 255, 0.05);
            }
            .long-position {
                color: #4CAF50;
            }
            .short-position {
                color: #f44336;
            }
            .performance-chart {
                height: 200px;
                background: rgba(255, 255, 255, 0.03);
                border-radius: 8px;
                margin-top: 10px;
                position: relative;
                overflow: hidden;
            }
            .chart-line {
                position: absolute;
                bottom: 0;
                left: 0;
                height: 100%;
                width: 100%;
                background: linear-gradient(to top, rgba(233, 69, 96, 0.1), transparent);
            }
            .chart-area {
                fill: url(#colorGradient);
                stroke: #e94560;
                stroke-width: 2;
            }
            .chart-x-axis, .chart-y-axis {
                stroke: #86c232;
                stroke-width: 1;
            }
            .chart-label {
                fill: #86c232;
                font-size: 12px;
            }
            .no-data {
                text-align: center;
                color: #86c232;
                font-style: italic;
                padding: 20px;
            }
            .timestamp {
                text-align: right;
                font-size: 12px;
                color: #86c232;
                margin-top: 10px;
            }
        </style>
        
        <div class="dashboard">
            <div class="header">
                <h1>MACD(6,32,9)策略交易系统</h1>
            </div>
            
            <!-- 账户概览 -->
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>账户总额</h3>
                    <div class="value">$%.2f</div>
                    <div class="change">
                        初始: $%.2f
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>可用余额</h3>
                    <div class="value">$%.2f</div>
                    <div class="change">
                        %s
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>总盈亏</h3>
                    <div class="value %s">$%.2f</div>
                    <div class="change %s">
                        (%.2f%%)
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>今日盈亏</h3>
                    <div class="value %s">$%.2f</div>
                    <div class="change">
                        今日交易: %d
                    </div>
                </div>
            </div>
            
            <!-- 交易统计 -->
            <div class="stats-grid">
                <div class="stat-card">
                    <h3>总交易次数</h3>
                    <div class="value">%d</div>
                </div>
                
                <div class="stat-card">
                    <h3>盈利交易</h3>
                    <div class="value positive">%d</div>
                </div>
                
                <div class="stat-card">
                    <h3>亏损交易</h3>
                    <div class="value negative">%d</div>
                </div>
                
                <div class="stat-card">
                    <h3>当前持仓</h3>
                    <div class="value neutral">%d</div>
                </div>
            </div>
            
            <!-- 当前持仓 -->
            <div class="section">
                <h2>当前持仓</h2>
                <table class="positions-table">
                    <thead>
                        <tr>
                            <th>交易对</th>
                            <th>方向</th>
                            <th>入场价格</th>
                            <th>当前价格</th>
                            <th>持仓数量</th>
                            <th>未实现盈亏</th>
                            <th>止损</th>
                            <th>止盈</th>
                            <th>入场时间</th>
                        </tr>
                    </thead>
                    <tbody>
                        %s
                    </tbody>
                </table>
            </div>
            
            <!-- 最新信号 -->
            <div class="section">
                <h2>最新信号</h2>
                <table class="signals-table">
                    <thead>
                        <tr>
                            <th>交易对</th>
                            <th>信号</th>
                            <th>强度</th>
                            <th>时间</th>
                        </tr>
                    </thead>
                    <tbody>
                        %s
                    </tbody>
                </table>
            </div>
            
            <!-- 系统状态 -->
            <div class="section">
                <h2>系统状态</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>服务器状态</h3>
                        <div class="value %s">%s</div>
                    </div>
                    <div class="stat-card">
                        <h3>API连接</h3>
                        <div class="value %s">%s</div>
                    </div>
                    <div class="stat-card">
                        <h3>循环次数</h3>
                        <div class="value">%d</div>
                    </div>
                </div>
            </div>
            
            <div class="timestamp">
                最后更新: %s
            </div>
        </div>
        """
        
        # 准备账户数据
        available_balance = account_info.get('available_balance', 0) if account_info else 0
        
        # 确定盈亏颜色
        total_pnl_color = "positive" if trade_stats.get('total_profit_loss', 0) >= 0 else "negative"
        daily_pnl_color = "positive" if trade_stats.get('daily_pnl', 0) >= 0 else "negative"
        
        # 准备持仓数据
        positions_html = ""
        if position_tracker['positions']:
            for symbol, pos in position_tracker['positions'].items():
                # 获取当前价格
                try:
                    ticker = exchange.fetch_ticker(symbol)
                    current_price = ticker['last']
                except:
                    current_price = pos['entry_price']
                    
                # 计算未实现盈亏
                if pos['side'] == 'long':
                    pnl_percentage = ((current_price - pos['entry_price']) / pos['entry_price']) * 100
                else:
                    pnl_percentage = ((pos['entry_price'] - current_price) / pos['entry_price']) * 100
                
                pnl_color = "positive" if pos['pnl'] >= 0 else "negative"
                side_class = "long-position" if pos['side'] == 'long' else "short-position"
                side_text = "做多" if pos['side'] == 'long' else "做空"
                
                positions_html += f"""
                <tr>
                    <td>{symbol}</td>
                    <td class="{side_class}">{side_text}</td>
                    <td>${pos['entry_price']:.4f}</td>
                    <td>${current_price:.4f}</td>
                    <td>{pos['size']}</td>
                    <td class="{pnl_color}">${pos['pnl']:.2f} ({pnl_percentage:.2f}%)</td>
                    <td>${pos['sl']:.4f}</td>
                    <td>${pos['tp']:.4f}</td>
                    <td>{pos['entry_time'].strftime('%Y-%m-%d %H:%M:%S')}</td>
                </tr>
                """
        else:
            positions_html = "<tr><td colspan='9' class='no-data'>暂无持仓</td></tr>"
        
        # 准备信号数据
        signals_html = ""
        recent_signals = sorted(latest_signals.items(), key=lambda x: x[1][2], reverse=True)[:10]  # 只显示最近10个信号
        if recent_signals:
            for symbol, (signal, strength, timestamp) in recent_signals:
                if signal:
                    signal_color = "positive" if signal == "做多" else "negative"
                    signals_html += f"""
                    <tr>
                        <td>{symbol}</td>
                        <td class="{signal_color}">{signal}</td>
                        <td>{strength}</td>
                        <td>{timestamp.strftime('%Y-%m-%d %H:%M:%S')}</td>
                    </tr>
                    """
        else:
            signals_html = "<tr><td colspan='4' class='no-data'>暂无信号</td></tr>"
        
        # 系统状态
        server_status_str = "在线" if server_status['is_online'] else "离线"
        server_status_color = "positive" if server_status['is_online'] else "negative"
        
        api_status_str = "连接成功" if test_api_connection() else "连接失败"
        api_status_color = "positive" if test_api_connection() else "negative"
        
        # 填充HTML模板
        dashboard_html = dashboard_html % (
            # 账户概览
            trade_stats.get('current_balance', 0),
            trade_stats.get('initial_balance', 0),
            available_balance,
            "可用资金充足" if available_balance > 10 else "余额不足",
            total_pnl_color,
            trade_stats.get('total_profit_loss', 0),
            total_pnl_color,
            total_pnl_percentage,
            daily_pnl_color,
            trade_stats.get('daily_pnl', 0),
            trade_stats.get('daily_trades', 0),
            
            # 交易统计
            trade_stats.get('total_trades', 0),
            trade_stats.get('winning_trades', 0),
            trade_stats.get('losing_trades', 0),
            len(position_tracker['positions']),
            
            # 持仓和信号
            positions_html,
            signals_html,
            
            # 系统状态
            server_status_color,
            server_status_str,
            api_status_color,
            api_status_str,
            loop_count,
            
            # 时间戳
            datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        )
        
        # 显示仪表板
        display(HTML(dashboard_html))
        
    except Exception as e:
        log_message("ERROR", f"显示仪表板失败: {str(e)}")
        traceback.print_exc()

# ============================================# 交易循环函数# ============================================def trading_loop():
    """主交易循环"""
    try:
        log_message("INFO", "启动交易循环...")
        
        # 自动获取欧易交易所排名前10的合约交易对 + 指定交易对
        trading_pairs = []
        
        try:
            # 尝试从交易所获取热门合约交易对
            log_message("INFO", "正在获取欧易交易所热门合约交易对...")
            
            # 获取所有合约交易对
            all_markets = exchange.load_markets()
            contracts = []
            
            # 筛选出活跃的USDT合约
            for symbol, market in all_markets.items():
                if market.get('active') and ':USDT' in symbol and market.get('type') == 'swap':
                    # 尝试获取交易量信息（如果可用）
                    try:
                        ticker = exchange.fetch_ticker(symbol)
                        volume = ticker.get('quoteVolume', 0)
                        contracts.append((symbol, volume))
                    except:
                        # 如果无法获取交易量，也添加到列表中
                        contracts.append((symbol, 0))
            
            # 按交易量排序，取前10个
            contracts.sort(key=lambda x: x[1], reverse=True)
            top_contracts = [contract[0] for contract in contracts[:10]]
            
            # 确保基本的主流币种在列表中
            essential_contracts = [
                'BTC/USDT:USDT', 'ETH/USDT:USDT', 'BNB/USDT:USDT', 'SOL/USDT:USDT',
                'XRP/USDT:USDT', 'ADA/USDT:USDT', 'DOGE/USDT:USDT', 'DOT/USDT:USDT',
                'AVAX/USDT:USDT', 'LTC/USDT:USDT'
            ]
            
            # 合并并去重
            all_contracts = list(set(top_contracts + essential_contracts))
            trading_pairs.extend(all_contracts)
            
            log_message("SUCCESS", f"获取前10合约交易对成功: {', '.join(all_contracts)}")
        except Exception as e:
            log_message("ERROR", f"获取热门合约交易对失败，使用默认列表: {str(e)}")
            # 如果获取失败，使用默认的前10合约交易对
            trading_pairs = [
                'BTC/USDT:USDT', 'ETH/USDT:USDT', 'BNB/USDT:USDT', 'SOL/USDT:USDT',
                'XRP/USDT:USDT', 'ADA/USDT:USDT', 'DOGE/USDT:USDT', 'DOT/USDT:USDT',
                'AVAX/USDT:USDT', 'LTC/USDT:USDT'
            ]
        
        # 添加指定的交易对
        specified_pairs = ['FIL/USDT:USDT', 'ZRO/USDT:USDT', 'WIF/USDT:USDT', 'WLD/USDT:USDT']
        for pair in specified_pairs:
            if pair not in trading_pairs:
                trading_pairs.append(pair)
        
        log_message("INFO", f"最终交易对列表: {', '.join(trading_pairs)}")
        
        # 初始化交易统计
        account_info = get_account_info()
        if account_info:
            trade_stats['initial_balance'] = account_info['total_balance']
            trade_stats['current_balance'] = account_info['total_balance']
            log_message("SUCCESS", f"初始余额: {trade_stats['initial_balance']:.2f} USDT")
        
        loop_count = 0
        last_trailing_stop_check = time.time()
        last_server_check = time.time()
        
        # 主循环
        while True:
            try:
                loop_count += 1
                log_message("INFO", f"\n{'='*60}")
                log_message("INFO", f"循环 #{loop_count} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                log_message("INFO", f"{'='*60}")
                
                # 检查服务器状态
                current_time = time.time()
                if current_time - last_server_check > SERVER_CHECK_INTERVAL:
                    is_online = check_server_status()
                    last_server_check = current_time
                    if not is_online:
                        log_message("WARNING", "服务器连接异常，将使用固定止损止盈")
                
                # 更新移动止损（仅在服务器在线时）
                if server_status['is_online'] and current_time - last_trailing_stop_check > TRAILING_STOP_CHECK_INTERVAL:
                    update_trailing_stops()
                    last_trailing_stop_check = current_time
                
                # 检查每日重置
                check_daily_reset()
                
                # 更新持仓状态
                update_positions()
                
                # 检查MACD交叉平仓条件
                check_macd_close_conditions()
                
                # 检查每个交易对的信号
                for symbol in trading_pairs:
                    try:
                        # 生成信号（EMA交叉 + ADX过滤）
                        signal, strength = generate_signal(symbol)
                        
                        # 更新最新信号
                        latest_signals[symbol] = (signal, strength, datetime.now())
                        
                        # 如果有信号，执行交易
                        if signal and strength > 40:  # 只交易强度大于40的信号
                            log_message("SIGNAL", f"{symbol} 生成{signal}信号，强度: {strength}")
                            execute_trade(symbol, signal, strength)
                        
                        # 避免请求过快
                        time.sleep(1)
                        
                    except Exception as e:
                        log_message("ERROR", f"{symbol} 处理信号时出错: {str(e)}")
                
                # 显示交易仪表板（每次循环都更新）
                display_dashboard()
                
                # 显示交易统计（每10个循环显示一次）
                if loop_count % 10 == 0:
                    display_trading_stats()
                
                # 等待下一个循环
                log_message("INFO", "等待60秒后继续下一个循环...")
                time.sleep(60)
                
            except Exception as e:
                log_message("ERROR", f"交易循环中出错: {str(e)}")
                traceback.print_exc()
                time.sleep(60)
                
    except KeyboardInterrupt:
        log_message("INFO", "交易循环被手动中断")
        display_dashboard()
        display_trading_stats()
    except Exception as e:
        log_message("ERROR", f"交易循环启动失败: {str(e)}")
        traceback.print_exc()

# ============================================
# 启动交易系统
# ============================================
if __name__ == "__main__":
    try:
        # 测试API连接
        if not test_api_connection():
            log_message("ERROR", "API连接测试失败，请检查配置")
            raise Exception("API连接失败")
        
        # 防止Colab掉线
        prevent_colab_timeout()
        
        # 显示启动信息
        log_message("SUCCESS", "=" * 60)
        log_message("SUCCESS", "MACD(6,32,9)策略实盘交易系统")
        log_message("SUCCESS", "=" * 60)
        log_message("INFO", f"杠杆: {DEFAULT_LEVERAGE}x")
        log_message("INFO", f"单次风险: {RISK_PER_TRADE*100}%")
        log_message("INFO", f"最大持仓: {MAX_OPEN_POSITIONS}")
        log_message("INFO", f"冷却期: {COOLDOWN_PERIOD//60}分钟")
        log_message("INFO", f"每日最大交易: {MAX_DAILY_TRADES}")
        log_message("INFO", f"每日最大亏损: {MAX_DAILY_LOSS*100}%")
        log_message("INFO", "使用30分钟K线图")
        log_message("INFO", "入场信号: MACD快线上穿/下穿慢线(金叉/死叉)")
        log_message("INFO", "震荡过滤: ADX < 20")
        log_message("INFO", "趋势确认: ADX > 25")
        log_message("INFO", "平仓条件: 止损/止盈")
        log_message("INFO", f"移动止损: 激活阈值 {TRAILING_STOP_ACTIVATION_PERCENTAGE*100}%, 回调 {TRAILING_STOP_CALLBACK_PERCENTAGE*100}%")
        log_message("INFO", "已移除交易对: MATIC/USDT:USDT")
        log_message("SUCCESS", "=" * 60)
        
        # 启动交易循环
        trading_loop()
        
    except Exception as e:
        log_message("ERROR", f"启动交易系统失败: {str(e)}")
        traceback.print_exc()